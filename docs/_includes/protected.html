<!-- _includes/protected.html -->
<style>
  /* Basic styling for the decryptor, can be customized */
  .protected-content-container {
    max-width: 800px;
    margin: 20px auto;
    padding: 30px;
    background-color: #fff;
    border-radius: 12px;
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
    font-family: 'Inter', sans-serif;
    color: #333;
  }
  .protected-content-container h2 {
    color: #2c3e50;
    text-align: center;
    margin-bottom: 25px;
  }
  .protected-content-container input[type="password"] {
    width: 100%;
    padding: 10px;
    margin-bottom: 15px;
    border: 1px solid #ddd;
    border-radius: 8px;
    box-sizing: border-box;
  }
  .protected-content-container button {
    padding: 12px 25px;
    background-color: #3498db;
    color: white;
    border: none;
    border-radius: 8px;
    cursor: pointer;
    font-size: 1em;
    transition: background-color 0.3s ease, transform 0.2s ease;
    display: block; /* Make button full width */
    width: 100%;
    box-sizing: border-box;
  }
  .protected-content-container button:hover {
    background-color: #2980b9;
    transform: translateY(-2px);
  }
  .protected-content-container button:active {
    transform: translateY(0);
  }
  .protected-content-container pre {
    background-color: #e9ecef;
    padding: 15px;
    border: 1px solid #ced4da;
    border-radius: 8px;
    white-space: pre-wrap;
    word-break: break-all;
    margin-top: 20px;
  }
  .protected-content-container .security-info {
    background-color: #e6ffe6;
    border: 1px solid #82e0aa;
    padding: 15px;
    border-radius: 8px;
    margin-bottom: 25px;
    color: #28a745;
  }
  .protected-content-container .error-message {
    color: #dc3545;
    font-weight: bold;
  }
  .protected-content-container .success-message {
    color: #28a745;
    font-weight: bold;
  }
  .protected-content-container .loading-message {
    color: #555;
    font-style: italic;
  }
  .protected-content-container label {
    display: block;
    margin-bottom: 8px;
    font-weight: bold;
    color: #555;
  }
</style>

<div class="protected-content-container">
  <h2>Protected Content</h2>

  <div class="security-info">
    <p>This content is encrypted using **AES-GCM (Galois/Counter Mode)**, providing both **confidentiality** and **integrity/authenticity**. If decryption is successful, you can be confident that the content is both secret and has not been tampered with.</p>
    <p><strong>Important:</strong> Decryption happens entirely in your browser. Your password is never sent to any server.</p>
  </div>

  <p>Please enter the password to view the content:</p>

  <label for="passwordInputProtected">Password:</label><br>
  <input type="password" id="passwordInputProtected" placeholder="Enter the password"><br>

  <button onclick="decryptProtectedContent()">Decrypt Content</button>

  <pre id="outputProtectedContent" class="output-box"></pre>
</div>

<script>
  // The path to the encrypted file, passed from Jekyll Liquid
  // This path is relative to the site root (e.g., /docs/emails/solovay/question.txt.enc)
  const ENCRYPTED_FILE_PATH = "{{ include.url }}";

  // Derive paths for salt and nonce files
  // Assuming the structure: /path/to/file.txt.enc, /path/to/file.txt.salt, /path/to/file.txt.nonce
  const SALT_FILE_PATH = ENCRYPTED_FILE_PATH.replace(/\.enc$/, '.salt');
  const NONCE_FILE_PATH = ENCRYPTED_FILE_PATH.replace(/\.enc$/, '.nonce');

  // PBKDF2 Iterations (must match C encryption program)
  const PBKDF2_ITERATIONS = 100000;
  const GCM_TAG_LENGTH_BITS = 128; // 16 bytes

  // --- Configuration for Raw GitHub Content URL ---
  // Based on your repository: https://github.com/ruplet/ruplet.github.io
  const GITHUB_USERNAME = "ruplet";
  // For user/organization pages (like ruplet.github.io), the repo name in the raw URL is the full domain.
  const GITHUB_REPO_NAME = "ruplet.github.io"; 
  const GITHUB_BRANCH = "main"; // Or 'master' if that's your default branch

  // --- Helper Functions ---
  function base64ToUint8Array(base64) {
    try {
      const binary_string = window.atob(base64);
      const len = binary_string.length;
      const bytes = new Uint8Array(len);
      for (let i = 0; i < len; i++) {
        bytes[i] = binary_string.charCodeAt(i);
      }
      return bytes;
    } catch (e) {
      throw new Error("Invalid Base64 string provided for conversion.");
    }
  }

  async function fetchFileContent(filePath) {
    // Construct the full raw.githubusercontent.com URL
    // filePath starts with a '/', so we don't need an extra '/' after GITHUB_BRANCH
    const rawUrl = `https://raw.githubusercontent.com/${GITHUB_USERNAME}/${GITHUB_REPO_NAME}/${GITHUB_BRANCH}${filePath}`;
    
    console.log(`Fetching: ${rawUrl}`);
    const response = await fetch(rawUrl);
    if (!response.ok) {
      throw new Error(`Failed to fetch ${rawUrl}: ${response.status} ${response.statusText || 'Network Error'}`);
    }
    return response.text(); // Return as text (Base64 string)
  }

  async function decryptProtectedContent() {
    const password = document.getElementById('passwordInputProtected').value;
    const outputElement = document.getElementById('outputProtectedContent');

    outputElement.textContent = "Fetching encrypted files...";
    outputElement.className = "output-box loading-message";

    if (!password) {
      outputElement.textContent = "❌ Error: Please enter the password.";
      outputElement.className = "output-box error-message";
      return;
    }

    try {
      // Fetch all three files concurrently
      const [b64CiphertextWithTag, b64Salt, b64Nonce] = await Promise.all([
        fetchFileContent(ENCRYPTED_FILE_PATH),
        fetchFileContent(SALT_FILE_PATH),
        fetchFileContent(NONCE_FILE_PATH)
      ]);

      outputElement.textContent = "Files fetched. Decrypting...";
      outputElement.className = "output-box loading-message";

      const salt = base64ToUint8Array(b64Salt);
      const nonce = base64ToUint8Array(b64Nonce);
      const fullCiphertextBuffer = base64ToUint8Array(b64CiphertextWithTag);

      // 1. Import the password as a CryptoKey for PBKDF2
      const passwordKey = await crypto.subtle.importKey(
        'raw',
        new TextEncoder().encode(password),
        { name: 'PBKDF2' },
        false,
        ['deriveKey']
      );

      // 2. Derive the AES key using PBKDF2
      const aesKey = await crypto.subtle.deriveKey(
        {
          name: 'PBKDF2',
          salt: salt,
          iterations: PBKDF2_ITERATIONS,
          hash: 'SHA-512',
        },
        passwordKey,
        { name: 'AES-GCM', length: 256 },
        false, // Not extractable (good for security)
        ['decrypt']
      );

      // 3. Decrypt the ciphertext with GCM
      const decryptedBuffer = await crypto.subtle.decrypt(
        {
          name: 'AES-GCM',
          iv: nonce,
          tagLength: GCM_TAG_LENGTH_BITS,
        },
        aesKey,
        fullCiphertextBuffer 
      );

      // 4. Decode the decrypted data (assuming UTF-8 text)
      const decryptedText = new TextDecoder().decode(decryptedBuffer);
      outputElement.textContent = `✅ Decrypted Content:\n\n${decryptedText}`;
      outputElement.className = "output-box success-message";

    } catch (e) {
      outputElement.textContent = `❌ Decryption failed: ${e.message}. This could be due to an incorrect password, corrupted files, or network issues.`;
      outputElement.className = "output-box error-message";
      console.error("Decryption error:", e);
    }
  }
</script>