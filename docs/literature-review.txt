problem:

jeśli chcemy mieć funkcję f: A -> B
to ona co prawda dowodzi że jeśli A to B,
ale w sposób ekstensjonalny: podaj przykład A, a podam ci przykład B.
ale czy w sposób intensjonalny to by nie było dużo silniejsze?
podaj mi sposób stworzenia A, a podam ci sposób stworzenia B


najważniejsze papiery teraz:
Neergaard, 2004
A Functional Language for Logarithmic Space
file:///home/pawel/978-3-540-30477-7_21.pdf

oraz bazujący na nim:
Ulrich Schopp, 2006
Space-efficient Computation by Interaction
https://ulrichschoepp.de/Docs/seci.pdf



mój plan: zapoczątkować program, a nie tylko zaliczyć pracę magisterską
coś jak OEIS, ale dla programów komputerowych
zjawisko obserwowalne na LeetCode to powoływanie się na inne zadania po numerach
indeks problemów z różnych stron z zadaniami algorytmicznymi

lazy can't have categorial coproducts
complexity effects of laziness, okasaki functional ds

jak silna jest potrzebna logika by stwierdzić spójność / sprzeczność zestawu aksjomatów?
czy syntax musi być drzewem?
teoria typów metajęzyka
najsłabszy syntax, który wyrazi wszystkie poprawne programy innego języka
taki syntax jest w stanie rozwiązać problem HALT dla rozważanego języka!!
szukamy takiego metajęzyka, żeby problem stopu podjęzyka był łatwy.

w FO nie odróżnimy dużego kwadratu od dużego prostokąta (dowód przez gry EF)

gap pomiędzy poprawnością semantyczną, a syntaktyczną: ekstensjonalność vs intensjonalność


problem enumeracji słów języka vs problem rozpoznawania języka
czy brak klasyfikacji 4-wymairowych manifoldow (https://mathoverflow.net/questions/73818/why-classification-of-4-manifolds-is-not-possible)
ma cos wspolnego z tym ze nie sklasyfikujemy wszystkich programow P (co ma zwiazek z P neq NP)
tj. ze jest nieskonczenie wiele technik programistycznych
semantic vs syntactic complexity classes

finding a language for combinatorial object (e.g. Sudoku board as a tuple (param1, param2, ...)) is a compression problem!
succint data structure

interpreter ogólnie logiki to język naturalny
forcing for axiom orthogonality. for which axiom sets forcing can be of use?
CNF, DNF are also languages!

głównie pytanie moich badań: ,,w jakim języku warto zapisywać obliczenia?''
tj. jaki formalizm jest dobry do opisu obliczeń

logiki na drzewie. czy dodanie drzew do teorii typów sprawia że język definiuje automaty na drzewach?

dany zbiór zawsze ma jakąś ,,naturalną'' strukturę danych - taką która się zgadza z 
językiem, w którym akurat to zdefiniowaliśmy. często to logika.

typy powinny iść w parze z funkcjonalnością - tak żeby nie trzeba było tracić
informacji o wykonanych obliczeniach poprzez zbyt generalne typy.

najmniejszy język który potradi wygenerować obiekty wszystkich typów języka

rozważyć graf reprezetnacji danych, gdzie edge to redukcja o jakiejś złożoności

kwatyfikator: możliwość zaaplikowania funkcji do całego zbioru oraz zagregować wszystkie wyniki od razu
kwantyfikator uniwersalny i egzystencjalny się cechuje bardzo prostą agregacją - trzymamy 1 bit
na agregację poprzednich wyników i możemy zrobić short-circuit

realizacja kwantyfikatora na komputerze wymaga zareprezentowania zbioru - możemy to zrobić explicite albo implicite

logika II rzędu jest trudna bo wymaga przeglądania bardzo skomplikowanych zbiorów.
być może byłaby łatwiejsza gdyby te skomplikowane zbiory były zadane przez ich ,,generatory''?

typ właściwy dla maszyny turinga to zawsze [Bit]

cała teoria typów to tylko lukier syntaktyczny!




succinct data structure
they are succinct, but enable efficient algorithms without decompression
lossless data compression - cool, but has to unpack


metody inferencji w sudoku. czy istnieje mały zbiór metod inferencji,
który jest w stanie rozwiązać wszystkie łamigłówki?
to pytanie brzmi bardzo podobnie do tego, że jeśli
p =/= np, to istnieje nieskonczenie wiele technik algorytmicznych


wpływ reprezentacji wejścia na złożoność problemu
-> teoria typów!

jeden model obliczeniowy: RAM machine with binary alphabet

czy liczby naturalne chcemy reprezentować jako
ciągi jedynek (unarnie) czy binarnie?

result needed:
when data on input is in a convenient form,
a reduction is in L, but if it the input is just represented
as a natural number (because every countable sequence can be numbered),
no efficient algorithm exists (try proving that the algorithm
would probably have to 'unpack' the structure, i.e. construct the
actual structure, which it is unable to because of the memory limit)


neil d jones book
http://hjemmesider.diku.dk/~neil/comp2book2007/book-whole.pdf

neil d jones: logspace, ptime
https://core.ac.uk/download/pdf/82651296.pdf

bonfante: logspace, ptime
https://inria.hal.science/inria-00105744/document

hofmann: logspace
https://www-lipn.univ-paris13.fr/~baillot/GEOCAL06/SLIDES/Hofmann1302.pdf

oitaven: logspace
https://www.degruyter.com/document/doi/10.1515/9783110324907.355/html


logspace vs grzegorczyk hierarchy.
G2 = linspace


przegląd ICC:
https://www.cs.unibo.it/~martini/BISS/martini-1.pdf
https://www.cs.unibo.it/~martini/BISS/martini-2.pdf
https://www.cs.unibo.it/~martini/BISS/martini-3.pdf
https://www.cs.unibo.it/~martini/BISS/
http://panhellenic-logic-symposium.org/12/slides/Day1_Ronchi.pdf

Gaboardi, an implicit characterization of PSPACE

https://arxiv.org/pdf/1006.0030.pdf


Niggl, Wunderlich: Implicit characterizations of FPTIME and NC revisited
https://www.sciencedirect.com/science/article/pii/S1567832609000113


Bellantoni and Cook, recursion-theoretic characterization
of polytime functions
https://www.cs.utoronto.ca/~sacook/homepage/ptime.pdf


pytanie: czy jedynym typem w jezyku programowania moze byc int?
to by otwieralo droge do po prostu primitive recursion,
hierarchii grzegorczyka i latwej skladni


The smallest class containing linear time and closed under subroutines is P. The smallest class containing log space and closed under subroutines is still log space. So P and L are the smallest robust classes for time and space respectively which is why they feel right for modeling efficient computation.
https://cstheory.stackexchange.com/a/3448/71933



Constant Time Factors Do Matter (Neil D. Jones)
NLIN-complete problem
https://dl.acm.org/doi/pdf/10.1145/167088.167244

Gurevich, Shelah: Nearly linear time
couple problems with defining DTIME(n) (dependency on computational model)
nearly-linear-time-complete problem under QL reductions
https://link.springer.com/content/pdf/10.1007/3-540-51237-3_10.pdf


Lind characterizes FLOGSPACE (1974)
do dupy papier! znowu log-bounded recursion!
https://dspace.mit.edu/handle/1721.1/148880

Cobham characterizes FPTIME
https://www.cs.toronto.edu/~sacook/homepage/cobham_intrinsic.pdf

Clote and Takeuti
recursion-theoretic characterization of complexity classes
(AC0(2), AC0(6), Flogspace)
page 163 pdf
https://link.springer.com/chapter/10.1007/978-1-4612-2566-9_6

Logspace without bounds (Isabel Otiavem)
provides recursion-theoretic characterization of FLOGSPACE,
similar to Clote and Takeuti
https://www.degruyter.com/document/doi/10.1515/9783110324907.355/html

To jest papier Lind, Meyer 1973; do dupy jest!
bo wymaga explicit boundu na wielkosc outputu (log-bounded recursion on notation)
Charakteryzacja log-space funkcji:
https://dl.acm.org/doi/pdf/10.1145/1008293.1008295


jeśli możemy zliczyć ile jest obiektów danego typu maszyną NP,
to problem: ile jest obiektów danego typu? jest w klasie #P
ta klasa ma FPRAS - fully polynomial random approximation scheme
czyli mozemy znalezc calkiem niezly lower bound zeby np. udowodnic
ze sa przynajmniej 2 obiekty spelniajace

moze to sie wiaze z theorems for free?

czy sudoku jest #P-complete? pewnie tak - no examples are known
https://cstheory.stackexchange.com/q/16119/71933
https://blog.computationalcomplexity.org/2020/08/sharp-p-and-issue-of-natural-problems.html


# classes and burnside lemma




typy dają opis danych, stanowią specyfikację programu
są deklaratywne, nie mówią jak uzyskać obiekt, tylko jakie ma
ostatecznie własności

język programowania daje opis programu. jest konstruktywny,
stanowi opis konstrukcji

słabsze teorie typów sprawiają, że łatwiej jest napisać poprawny program - 
bo nie jesteśmy w stanie ściśle sformułować pożądanych własności wyniku

Bonfante LOGSPACE, PTIME (decision)
https://inria.hal.science/inria-00105744/document

cons-free programs, Neil D Jones 
https://arxiv.org/pdf/2008.02932.pdf

A Formalization of Polytime Functions (Heraud, Nowak 2011)
lepsza, nowsza charakteryzacja PTIME na [Bit]:
https://inria.hal.science/hal-00654217/file/itp2011-arxiv.pdf

Neergaard: A Functional Language for Logarithmic Space, 2004
file:///home/pawel/978-3-540-30477-7_21.pdf
This appears to be the first  
such characterization of lf-computable functions (not just predicates)


jakis chujowy jezyk programowania, tez dla ptime: Pola
https://cs.ioc.ee/fics09/proceedings/invited1.pdf


system typów dla LOGSPACE, oparty o prace Moller-Neergaard i Mairsona
Ulrich Schopp
tu sa fajne referencje!
https://ulrichschoepp.de/Docs/seci.pdf

18 17 4 13 14



it is not true that a programming language which can self-interpret,
cannot be decidable:
https://cs.stackexchange.com/questions/53485/implicit-complexity-and-interpretation-of-total-languages?rq=1

On Syntactic and Semantic Complexity Classes
Anuj Dawar
University of Cambridge Computer Laboratory
Spitalfields Day, Isaac Newton Institute, 9 January 2012
syntactical complexity class:
https://www.newton.ac.uk/files/seminar/20120109163017301-152985.pdf
e.g. NP = ESO (Fagin 1974), so NP is syntactical 
major open problem: 
Does P admit a syntactic characterisation?
Can the class P be “built up from below” by finitely many operations?
If a complexity class C has a complete problem L, it is a syntactic class.
because we can enumerat all AC0 reductions
Two Possible Worlds
Either
• there is no effective syntax for inv-P
• there is no classification possible of polynomial-time graph problems
• there is an inexhaustible supply of efficient algorithmic techniques to be
discovered
• P 6= NP
Or,
• there is an effective syntax for inv-P
• there is a P-complete graph problem under FO-reductions
• all polynomial-time graph problems can be solved by easy variations of one
algorithm.



artykuł Leivanta tutaj:
strona 329
Ramified Recurrence and
Computational Complexity I:
Word Recurrence and Poly-time 
file:///home/pawel/Downloads/978-1-4612-2566-9%20(2).pdf

Kristiansen, Voda 2005: languages for LOGSPACE, LINSPACE, P, PSPACE etc.
https://www.researchgate.net/publication/220673222_Programming_Languages_Capturing_Complexity_Classes




jaki jest najbardziej naturalny problem K-kompletny?
rozważamy coraz słabsze redukcje, aż coraz mniej zostaje problemów,
do których możemy przy tak słabych redukcjach zredukować resztę problemów

linear hierarchy
https://www.sciencedirect.com/science/article/pii/S0304397503001336?ref=pdf_download&fr=RR-2&rr=84a08baa2fb7f2b8#page=9&zoom=100,0,58


Adescriptive complexity approach to
the linear hierarchy


Logspace on streams:
https://www.mimuw.edu.pl/~lukaszcz/logspace.pdf



Leaf language characterization
https://cstheory.stackexchange.com/questions/761/do-all-complexity-classes-have-a-leaf-language-characterization

file:///home/pawel/Downloads/b106980.pdf
https://complexityzoo.net/Complexity_Zoo:P#pr

An interesting difference is that PR functions can be explicitly enumerated, whereas functions in R cannot be (since otherwise the halting problem would be decidable). In this sense, PR is a "syntactic" class whereas R is "semantic."

Register machines
https://web.mat.bham.ac.uk/R.W.Kaye/computability/prmachines.html
Grzegorczyk hierarchy!
Primitive recursive functions
lexicogaphic termination, liquidHaskell
https://goto.ucsd.edu/~gridaphobe/liquid/haskell/blog/blog/2013/12/15/lexicographic-termination.lhs/


Każdy język jest wykrywany przez funkcję {0, 1}* -> {true, false}.
Ale {0, 1}* to jest przestrzeń zwarta jako homeomorficzna do zbioru Cantora.
nieeee, bo sa tez skonczone cigi: 001, a zeby byla zwarta to
zbior samych nieskonczonych bysmy musieli rozwazac

czy my potrzebujemy liczb rzeczywistych?
co jak rozważymy maszyny Turinga operujące na liczbach rzeczywistych?
https://link.springer.com/book/10.1007/978-1-4684-6802-1
https://cs.stackexchange.com/questions/29567/are-there-established-complexity-classes-with-real-numbers


Jaka jest fizyczna natura obliczeń? W jakiej fizyce żyjemy?
- operowanie na liczbach rzeczywistych
  (teza churcha-turinga dotyczy funkcji N -> N)
- Malament-Hogarth spacetime; relatywistyczne maszyny turinga,
  które mogą podejrzeć przyszłość

https://plato.stanford.edu/entries/computation-physicalsystems/


conversion of MSO to NFA is non-elementary
conversion of NFA to MSO is linear-time
what are the best data representations?
what about languages over the unary alphabet?
are there np-hard languages over the unary alphabet?
can the only data type in the language be {1^n: n in Nat}?
it seems natural that the data type for computers is { {0,1}^n: n in Nat},
but for set-theory based mathematics, it's Set = Empty | {Set},
where {} stands for... a set. So like a list, but with no order and no duplicates

Computational content of set theory
https://people.math.ethz.ch/~engeler/computing_aspects.pdf
https://terrytao.wordpress.com/2010/03/19/a-computational-perspective-on-set-theory/
https://plato.stanford.edu/entries/set-theory/#:~:text=Thus%2C%20set%20theory%20has%20become,the%20axioms%20of%20set%20theory.



Czy grafy moga modelowac kazda logike?
To jest pytanie o to, czy konkretna teoria grafów
może być foundations of mathematics
https://mathoverflow.net/q/397581


https://philosophy.stackexchange.com/questions/87027/set-theory-vs-type-theory-vs-category-theory

https://mathoverflow.net/questions/364228/are-categories-special-foundationally

What do we want a foundation to be?
https://sites.socsci.uci.edu/~pjmaddy/bio/What%20do%20we%20want%20-%20final

https://terrytao.wordpress.com/2010/03/19/a-computational-perspective-on-set-theory/

https://mathoverflow.net/questions/8731/categorical-foundations-without-set-theory

https://mathoverflow.net/questions/360578/category-theory-and-set-theory-just-a-different-language-or-different-foundati
https://mathoverflow.net/questions/352298/could-groups-be-used-instead-of-sets-as-a-foundation-of-mathematics?noredirect=1&lq=1
https://mathoverflow.net/questions/24773/why-do-categorical-foundationalists-want-to-escape-set-theory
https://mathoverflow.net/questions/9269/category-of-categories-as-a-foundation-of-mathematics

